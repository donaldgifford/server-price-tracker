// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"
	json "encoding/json"

	domain "github.com/donaldgifford/server-price-tracker/pkg/types"

	mock "github.com/stretchr/testify/mock"

	store "github.com/donaldgifford/server-price-tracker/internal/store"
)

// MockStore is an autogenerated mock type for the Store type
type MockStore struct {
	mock.Mock
}

type MockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStore) EXPECT() *MockStore_Expecter {
	return &MockStore_Expecter{mock: &_m.Mock}
}

// CountBaselinesByMaturity provides a mock function with given fields: ctx
func (_m *MockStore) CountBaselinesByMaturity(ctx context.Context) (int, int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountBaselinesByMaturity")
	}

	var r0 int
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) int); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context) error); ok {
		r2 = rf(ctx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockStore_CountBaselinesByMaturity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountBaselinesByMaturity'
type MockStore_CountBaselinesByMaturity_Call struct {
	*mock.Call
}

// CountBaselinesByMaturity is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) CountBaselinesByMaturity(ctx interface{}) *MockStore_CountBaselinesByMaturity_Call {
	return &MockStore_CountBaselinesByMaturity_Call{Call: _e.mock.On("CountBaselinesByMaturity", ctx)}
}

func (_c *MockStore_CountBaselinesByMaturity_Call) Run(run func(ctx context.Context)) *MockStore_CountBaselinesByMaturity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_CountBaselinesByMaturity_Call) Return(cold int, warm int, err error) *MockStore_CountBaselinesByMaturity_Call {
	_c.Call.Return(cold, warm, err)
	return _c
}

func (_c *MockStore_CountBaselinesByMaturity_Call) RunAndReturn(run func(context.Context) (int, int, error)) *MockStore_CountBaselinesByMaturity_Call {
	_c.Call.Return(run)
	return _c
}

// CountIncompleteExtractions provides a mock function with given fields: ctx
func (_m *MockStore) CountIncompleteExtractions(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountIncompleteExtractions")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CountIncompleteExtractions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountIncompleteExtractions'
type MockStore_CountIncompleteExtractions_Call struct {
	*mock.Call
}

// CountIncompleteExtractions is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) CountIncompleteExtractions(ctx interface{}) *MockStore_CountIncompleteExtractions_Call {
	return &MockStore_CountIncompleteExtractions_Call{Call: _e.mock.On("CountIncompleteExtractions", ctx)}
}

func (_c *MockStore_CountIncompleteExtractions_Call) Run(run func(ctx context.Context)) *MockStore_CountIncompleteExtractions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_CountIncompleteExtractions_Call) Return(_a0 int, _a1 error) *MockStore_CountIncompleteExtractions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CountIncompleteExtractions_Call) RunAndReturn(run func(context.Context) (int, error)) *MockStore_CountIncompleteExtractions_Call {
	_c.Call.Return(run)
	return _c
}

// CountIncompleteExtractionsByType provides a mock function with given fields: ctx
func (_m *MockStore) CountIncompleteExtractionsByType(ctx context.Context) (map[string]int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountIncompleteExtractionsByType")
	}

	var r0 map[string]int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (map[string]int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) map[string]int); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CountIncompleteExtractionsByType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountIncompleteExtractionsByType'
type MockStore_CountIncompleteExtractionsByType_Call struct {
	*mock.Call
}

// CountIncompleteExtractionsByType is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) CountIncompleteExtractionsByType(ctx interface{}) *MockStore_CountIncompleteExtractionsByType_Call {
	return &MockStore_CountIncompleteExtractionsByType_Call{Call: _e.mock.On("CountIncompleteExtractionsByType", ctx)}
}

func (_c *MockStore_CountIncompleteExtractionsByType_Call) Run(run func(ctx context.Context)) *MockStore_CountIncompleteExtractionsByType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_CountIncompleteExtractionsByType_Call) Return(_a0 map[string]int, _a1 error) *MockStore_CountIncompleteExtractionsByType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CountIncompleteExtractionsByType_Call) RunAndReturn(run func(context.Context) (map[string]int, error)) *MockStore_CountIncompleteExtractionsByType_Call {
	_c.Call.Return(run)
	return _c
}

// CountListings provides a mock function with given fields: ctx
func (_m *MockStore) CountListings(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountListings")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CountListings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountListings'
type MockStore_CountListings_Call struct {
	*mock.Call
}

// CountListings is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) CountListings(ctx interface{}) *MockStore_CountListings_Call {
	return &MockStore_CountListings_Call{Call: _e.mock.On("CountListings", ctx)}
}

func (_c *MockStore_CountListings_Call) Run(run func(ctx context.Context)) *MockStore_CountListings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_CountListings_Call) Return(_a0 int, _a1 error) *MockStore_CountListings_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CountListings_Call) RunAndReturn(run func(context.Context) (int, error)) *MockStore_CountListings_Call {
	_c.Call.Return(run)
	return _c
}

// CountPendingAlerts provides a mock function with given fields: ctx
func (_m *MockStore) CountPendingAlerts(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountPendingAlerts")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CountPendingAlerts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountPendingAlerts'
type MockStore_CountPendingAlerts_Call struct {
	*mock.Call
}

// CountPendingAlerts is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) CountPendingAlerts(ctx interface{}) *MockStore_CountPendingAlerts_Call {
	return &MockStore_CountPendingAlerts_Call{Call: _e.mock.On("CountPendingAlerts", ctx)}
}

func (_c *MockStore_CountPendingAlerts_Call) Run(run func(ctx context.Context)) *MockStore_CountPendingAlerts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_CountPendingAlerts_Call) Return(_a0 int, _a1 error) *MockStore_CountPendingAlerts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CountPendingAlerts_Call) RunAndReturn(run func(context.Context) (int, error)) *MockStore_CountPendingAlerts_Call {
	_c.Call.Return(run)
	return _c
}

// CountProductKeysWithoutBaseline provides a mock function with given fields: ctx
func (_m *MockStore) CountProductKeysWithoutBaseline(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountProductKeysWithoutBaseline")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CountProductKeysWithoutBaseline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountProductKeysWithoutBaseline'
type MockStore_CountProductKeysWithoutBaseline_Call struct {
	*mock.Call
}

// CountProductKeysWithoutBaseline is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) CountProductKeysWithoutBaseline(ctx interface{}) *MockStore_CountProductKeysWithoutBaseline_Call {
	return &MockStore_CountProductKeysWithoutBaseline_Call{Call: _e.mock.On("CountProductKeysWithoutBaseline", ctx)}
}

func (_c *MockStore_CountProductKeysWithoutBaseline_Call) Run(run func(ctx context.Context)) *MockStore_CountProductKeysWithoutBaseline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_CountProductKeysWithoutBaseline_Call) Return(_a0 int, _a1 error) *MockStore_CountProductKeysWithoutBaseline_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CountProductKeysWithoutBaseline_Call) RunAndReturn(run func(context.Context) (int, error)) *MockStore_CountProductKeysWithoutBaseline_Call {
	_c.Call.Return(run)
	return _c
}

// CountUnextractedListings provides a mock function with given fields: ctx
func (_m *MockStore) CountUnextractedListings(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountUnextractedListings")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CountUnextractedListings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountUnextractedListings'
type MockStore_CountUnextractedListings_Call struct {
	*mock.Call
}

// CountUnextractedListings is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) CountUnextractedListings(ctx interface{}) *MockStore_CountUnextractedListings_Call {
	return &MockStore_CountUnextractedListings_Call{Call: _e.mock.On("CountUnextractedListings", ctx)}
}

func (_c *MockStore_CountUnextractedListings_Call) Run(run func(ctx context.Context)) *MockStore_CountUnextractedListings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_CountUnextractedListings_Call) Return(_a0 int, _a1 error) *MockStore_CountUnextractedListings_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CountUnextractedListings_Call) RunAndReturn(run func(context.Context) (int, error)) *MockStore_CountUnextractedListings_Call {
	_c.Call.Return(run)
	return _c
}

// CountUnscoredListings provides a mock function with given fields: ctx
func (_m *MockStore) CountUnscoredListings(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountUnscoredListings")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CountUnscoredListings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountUnscoredListings'
type MockStore_CountUnscoredListings_Call struct {
	*mock.Call
}

// CountUnscoredListings is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) CountUnscoredListings(ctx interface{}) *MockStore_CountUnscoredListings_Call {
	return &MockStore_CountUnscoredListings_Call{Call: _e.mock.On("CountUnscoredListings", ctx)}
}

func (_c *MockStore_CountUnscoredListings_Call) Run(run func(ctx context.Context)) *MockStore_CountUnscoredListings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_CountUnscoredListings_Call) Return(_a0 int, _a1 error) *MockStore_CountUnscoredListings_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CountUnscoredListings_Call) RunAndReturn(run func(context.Context) (int, error)) *MockStore_CountUnscoredListings_Call {
	_c.Call.Return(run)
	return _c
}

// CountWatches provides a mock function with given fields: ctx
func (_m *MockStore) CountWatches(ctx context.Context) (int, int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountWatches")
	}

	var r0 int
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) int); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context) error); ok {
		r2 = rf(ctx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockStore_CountWatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountWatches'
type MockStore_CountWatches_Call struct {
	*mock.Call
}

// CountWatches is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) CountWatches(ctx interface{}) *MockStore_CountWatches_Call {
	return &MockStore_CountWatches_Call{Call: _e.mock.On("CountWatches", ctx)}
}

func (_c *MockStore_CountWatches_Call) Run(run func(ctx context.Context)) *MockStore_CountWatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_CountWatches_Call) Return(total int, enabled int, err error) *MockStore_CountWatches_Call {
	_c.Call.Return(total, enabled, err)
	return _c
}

func (_c *MockStore_CountWatches_Call) RunAndReturn(run func(context.Context) (int, int, error)) *MockStore_CountWatches_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAlert provides a mock function with given fields: ctx, a
func (_m *MockStore) CreateAlert(ctx context.Context, a *domain.Alert) error {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for CreateAlert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.Alert) error); ok {
		r0 = rf(ctx, a)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_CreateAlert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAlert'
type MockStore_CreateAlert_Call struct {
	*mock.Call
}

// CreateAlert is a helper method to define mock.On call
//   - ctx context.Context
//   - a *domain.Alert
func (_e *MockStore_Expecter) CreateAlert(ctx interface{}, a interface{}) *MockStore_CreateAlert_Call {
	return &MockStore_CreateAlert_Call{Call: _e.mock.On("CreateAlert", ctx, a)}
}

func (_c *MockStore_CreateAlert_Call) Run(run func(ctx context.Context, a *domain.Alert)) *MockStore_CreateAlert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.Alert))
	})
	return _c
}

func (_c *MockStore_CreateAlert_Call) Return(_a0 error) *MockStore_CreateAlert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_CreateAlert_Call) RunAndReturn(run func(context.Context, *domain.Alert) error) *MockStore_CreateAlert_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWatch provides a mock function with given fields: ctx, w
func (_m *MockStore) CreateWatch(ctx context.Context, w *domain.Watch) error {
	ret := _m.Called(ctx, w)

	if len(ret) == 0 {
		panic("no return value specified for CreateWatch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.Watch) error); ok {
		r0 = rf(ctx, w)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_CreateWatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWatch'
type MockStore_CreateWatch_Call struct {
	*mock.Call
}

// CreateWatch is a helper method to define mock.On call
//   - ctx context.Context
//   - w *domain.Watch
func (_e *MockStore_Expecter) CreateWatch(ctx interface{}, w interface{}) *MockStore_CreateWatch_Call {
	return &MockStore_CreateWatch_Call{Call: _e.mock.On("CreateWatch", ctx, w)}
}

func (_c *MockStore_CreateWatch_Call) Run(run func(ctx context.Context, w *domain.Watch)) *MockStore_CreateWatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.Watch))
	})
	return _c
}

func (_c *MockStore_CreateWatch_Call) Return(_a0 error) *MockStore_CreateWatch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_CreateWatch_Call) RunAndReturn(run func(context.Context, *domain.Watch) error) *MockStore_CreateWatch_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteWatch provides a mock function with given fields: ctx, id
func (_m *MockStore) DeleteWatch(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWatch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_DeleteWatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteWatch'
type MockStore_DeleteWatch_Call struct {
	*mock.Call
}

// DeleteWatch is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockStore_Expecter) DeleteWatch(ctx interface{}, id interface{}) *MockStore_DeleteWatch_Call {
	return &MockStore_DeleteWatch_Call{Call: _e.mock.On("DeleteWatch", ctx, id)}
}

func (_c *MockStore_DeleteWatch_Call) Run(run func(ctx context.Context, id string)) *MockStore_DeleteWatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStore_DeleteWatch_Call) Return(_a0 error) *MockStore_DeleteWatch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_DeleteWatch_Call) RunAndReturn(run func(context.Context, string) error) *MockStore_DeleteWatch_Call {
	_c.Call.Return(run)
	return _c
}

// GetBaseline provides a mock function with given fields: ctx, productKey
func (_m *MockStore) GetBaseline(ctx context.Context, productKey string) (*domain.PriceBaseline, error) {
	ret := _m.Called(ctx, productKey)

	if len(ret) == 0 {
		panic("no return value specified for GetBaseline")
	}

	var r0 *domain.PriceBaseline
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.PriceBaseline, error)); ok {
		return rf(ctx, productKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.PriceBaseline); ok {
		r0 = rf(ctx, productKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.PriceBaseline)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, productKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetBaseline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBaseline'
type MockStore_GetBaseline_Call struct {
	*mock.Call
}

// GetBaseline is a helper method to define mock.On call
//   - ctx context.Context
//   - productKey string
func (_e *MockStore_Expecter) GetBaseline(ctx interface{}, productKey interface{}) *MockStore_GetBaseline_Call {
	return &MockStore_GetBaseline_Call{Call: _e.mock.On("GetBaseline", ctx, productKey)}
}

func (_c *MockStore_GetBaseline_Call) Run(run func(ctx context.Context, productKey string)) *MockStore_GetBaseline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStore_GetBaseline_Call) Return(_a0 *domain.PriceBaseline, _a1 error) *MockStore_GetBaseline_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetBaseline_Call) RunAndReturn(run func(context.Context, string) (*domain.PriceBaseline, error)) *MockStore_GetBaseline_Call {
	_c.Call.Return(run)
	return _c
}

// GetListing provides a mock function with given fields: ctx, ebayID
func (_m *MockStore) GetListing(ctx context.Context, ebayID string) (*domain.Listing, error) {
	ret := _m.Called(ctx, ebayID)

	if len(ret) == 0 {
		panic("no return value specified for GetListing")
	}

	var r0 *domain.Listing
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.Listing, error)); ok {
		return rf(ctx, ebayID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.Listing); ok {
		r0 = rf(ctx, ebayID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Listing)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, ebayID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetListing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetListing'
type MockStore_GetListing_Call struct {
	*mock.Call
}

// GetListing is a helper method to define mock.On call
//   - ctx context.Context
//   - ebayID string
func (_e *MockStore_Expecter) GetListing(ctx interface{}, ebayID interface{}) *MockStore_GetListing_Call {
	return &MockStore_GetListing_Call{Call: _e.mock.On("GetListing", ctx, ebayID)}
}

func (_c *MockStore_GetListing_Call) Run(run func(ctx context.Context, ebayID string)) *MockStore_GetListing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStore_GetListing_Call) Return(_a0 *domain.Listing, _a1 error) *MockStore_GetListing_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetListing_Call) RunAndReturn(run func(context.Context, string) (*domain.Listing, error)) *MockStore_GetListing_Call {
	_c.Call.Return(run)
	return _c
}

// GetListingByID provides a mock function with given fields: ctx, id
func (_m *MockStore) GetListingByID(ctx context.Context, id string) (*domain.Listing, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetListingByID")
	}

	var r0 *domain.Listing
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.Listing, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.Listing); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Listing)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetListingByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetListingByID'
type MockStore_GetListingByID_Call struct {
	*mock.Call
}

// GetListingByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockStore_Expecter) GetListingByID(ctx interface{}, id interface{}) *MockStore_GetListingByID_Call {
	return &MockStore_GetListingByID_Call{Call: _e.mock.On("GetListingByID", ctx, id)}
}

func (_c *MockStore_GetListingByID_Call) Run(run func(ctx context.Context, id string)) *MockStore_GetListingByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStore_GetListingByID_Call) Return(_a0 *domain.Listing, _a1 error) *MockStore_GetListingByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetListingByID_Call) RunAndReturn(run func(context.Context, string) (*domain.Listing, error)) *MockStore_GetListingByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetWatch provides a mock function with given fields: ctx, id
func (_m *MockStore) GetWatch(ctx context.Context, id string) (*domain.Watch, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetWatch")
	}

	var r0 *domain.Watch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.Watch, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.Watch); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Watch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetWatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWatch'
type MockStore_GetWatch_Call struct {
	*mock.Call
}

// GetWatch is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockStore_Expecter) GetWatch(ctx interface{}, id interface{}) *MockStore_GetWatch_Call {
	return &MockStore_GetWatch_Call{Call: _e.mock.On("GetWatch", ctx, id)}
}

func (_c *MockStore_GetWatch_Call) Run(run func(ctx context.Context, id string)) *MockStore_GetWatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStore_GetWatch_Call) Return(_a0 *domain.Watch, _a1 error) *MockStore_GetWatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetWatch_Call) RunAndReturn(run func(context.Context, string) (*domain.Watch, error)) *MockStore_GetWatch_Call {
	_c.Call.Return(run)
	return _c
}

// ListAlertsByWatch provides a mock function with given fields: ctx, watchID, limit
func (_m *MockStore) ListAlertsByWatch(ctx context.Context, watchID string, limit int) ([]domain.Alert, error) {
	ret := _m.Called(ctx, watchID, limit)

	if len(ret) == 0 {
		panic("no return value specified for ListAlertsByWatch")
	}

	var r0 []domain.Alert
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int) ([]domain.Alert, error)); ok {
		return rf(ctx, watchID, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int) []domain.Alert); ok {
		r0 = rf(ctx, watchID, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Alert)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = rf(ctx, watchID, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_ListAlertsByWatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAlertsByWatch'
type MockStore_ListAlertsByWatch_Call struct {
	*mock.Call
}

// ListAlertsByWatch is a helper method to define mock.On call
//   - ctx context.Context
//   - watchID string
//   - limit int
func (_e *MockStore_Expecter) ListAlertsByWatch(ctx interface{}, watchID interface{}, limit interface{}) *MockStore_ListAlertsByWatch_Call {
	return &MockStore_ListAlertsByWatch_Call{Call: _e.mock.On("ListAlertsByWatch", ctx, watchID, limit)}
}

func (_c *MockStore_ListAlertsByWatch_Call) Run(run func(ctx context.Context, watchID string, limit int)) *MockStore_ListAlertsByWatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockStore_ListAlertsByWatch_Call) Return(_a0 []domain.Alert, _a1 error) *MockStore_ListAlertsByWatch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_ListAlertsByWatch_Call) RunAndReturn(run func(context.Context, string, int) ([]domain.Alert, error)) *MockStore_ListAlertsByWatch_Call {
	_c.Call.Return(run)
	return _c
}

// ListBaselines provides a mock function with given fields: ctx
func (_m *MockStore) ListBaselines(ctx context.Context) ([]domain.PriceBaseline, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListBaselines")
	}

	var r0 []domain.PriceBaseline
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]domain.PriceBaseline, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []domain.PriceBaseline); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.PriceBaseline)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_ListBaselines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBaselines'
type MockStore_ListBaselines_Call struct {
	*mock.Call
}

// ListBaselines is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) ListBaselines(ctx interface{}) *MockStore_ListBaselines_Call {
	return &MockStore_ListBaselines_Call{Call: _e.mock.On("ListBaselines", ctx)}
}

func (_c *MockStore_ListBaselines_Call) Run(run func(ctx context.Context)) *MockStore_ListBaselines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_ListBaselines_Call) Return(_a0 []domain.PriceBaseline, _a1 error) *MockStore_ListBaselines_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_ListBaselines_Call) RunAndReturn(run func(context.Context) ([]domain.PriceBaseline, error)) *MockStore_ListBaselines_Call {
	_c.Call.Return(run)
	return _c
}

// ListIncompleteExtractions provides a mock function with given fields: ctx, componentType, limit
func (_m *MockStore) ListIncompleteExtractions(ctx context.Context, componentType string, limit int) ([]domain.Listing, error) {
	ret := _m.Called(ctx, componentType, limit)

	if len(ret) == 0 {
		panic("no return value specified for ListIncompleteExtractions")
	}

	var r0 []domain.Listing
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int) ([]domain.Listing, error)); ok {
		return rf(ctx, componentType, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int) []domain.Listing); ok {
		r0 = rf(ctx, componentType, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Listing)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = rf(ctx, componentType, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_ListIncompleteExtractions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListIncompleteExtractions'
type MockStore_ListIncompleteExtractions_Call struct {
	*mock.Call
}

// ListIncompleteExtractions is a helper method to define mock.On call
//   - ctx context.Context
//   - componentType string
//   - limit int
func (_e *MockStore_Expecter) ListIncompleteExtractions(ctx interface{}, componentType interface{}, limit interface{}) *MockStore_ListIncompleteExtractions_Call {
	return &MockStore_ListIncompleteExtractions_Call{Call: _e.mock.On("ListIncompleteExtractions", ctx, componentType, limit)}
}

func (_c *MockStore_ListIncompleteExtractions_Call) Run(run func(ctx context.Context, componentType string, limit int)) *MockStore_ListIncompleteExtractions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockStore_ListIncompleteExtractions_Call) Return(_a0 []domain.Listing, _a1 error) *MockStore_ListIncompleteExtractions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_ListIncompleteExtractions_Call) RunAndReturn(run func(context.Context, string, int) ([]domain.Listing, error)) *MockStore_ListIncompleteExtractions_Call {
	_c.Call.Return(run)
	return _c
}

// ListListings provides a mock function with given fields: ctx, opts
func (_m *MockStore) ListListings(ctx context.Context, opts *store.ListingQuery) ([]domain.Listing, int, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ListListings")
	}

	var r0 []domain.Listing
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *store.ListingQuery) ([]domain.Listing, int, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *store.ListingQuery) []domain.Listing); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Listing)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *store.ListingQuery) int); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *store.ListingQuery) error); ok {
		r2 = rf(ctx, opts)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockStore_ListListings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListListings'
type MockStore_ListListings_Call struct {
	*mock.Call
}

// ListListings is a helper method to define mock.On call
//   - ctx context.Context
//   - opts *store.ListingQuery
func (_e *MockStore_Expecter) ListListings(ctx interface{}, opts interface{}) *MockStore_ListListings_Call {
	return &MockStore_ListListings_Call{Call: _e.mock.On("ListListings", ctx, opts)}
}

func (_c *MockStore_ListListings_Call) Run(run func(ctx context.Context, opts *store.ListingQuery)) *MockStore_ListListings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*store.ListingQuery))
	})
	return _c
}

func (_c *MockStore_ListListings_Call) Return(_a0 []domain.Listing, _a1 int, _a2 error) *MockStore_ListListings_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockStore_ListListings_Call) RunAndReturn(run func(context.Context, *store.ListingQuery) ([]domain.Listing, int, error)) *MockStore_ListListings_Call {
	_c.Call.Return(run)
	return _c
}

// ListPendingAlerts provides a mock function with given fields: ctx
func (_m *MockStore) ListPendingAlerts(ctx context.Context) ([]domain.Alert, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListPendingAlerts")
	}

	var r0 []domain.Alert
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]domain.Alert, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []domain.Alert); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Alert)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_ListPendingAlerts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPendingAlerts'
type MockStore_ListPendingAlerts_Call struct {
	*mock.Call
}

// ListPendingAlerts is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) ListPendingAlerts(ctx interface{}) *MockStore_ListPendingAlerts_Call {
	return &MockStore_ListPendingAlerts_Call{Call: _e.mock.On("ListPendingAlerts", ctx)}
}

func (_c *MockStore_ListPendingAlerts_Call) Run(run func(ctx context.Context)) *MockStore_ListPendingAlerts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_ListPendingAlerts_Call) Return(_a0 []domain.Alert, _a1 error) *MockStore_ListPendingAlerts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_ListPendingAlerts_Call) RunAndReturn(run func(context.Context) ([]domain.Alert, error)) *MockStore_ListPendingAlerts_Call {
	_c.Call.Return(run)
	return _c
}

// ListUnextractedListings provides a mock function with given fields: ctx, limit
func (_m *MockStore) ListUnextractedListings(ctx context.Context, limit int) ([]domain.Listing, error) {
	ret := _m.Called(ctx, limit)

	if len(ret) == 0 {
		panic("no return value specified for ListUnextractedListings")
	}

	var r0 []domain.Listing
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]domain.Listing, error)); ok {
		return rf(ctx, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []domain.Listing); ok {
		r0 = rf(ctx, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Listing)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_ListUnextractedListings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUnextractedListings'
type MockStore_ListUnextractedListings_Call struct {
	*mock.Call
}

// ListUnextractedListings is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
func (_e *MockStore_Expecter) ListUnextractedListings(ctx interface{}, limit interface{}) *MockStore_ListUnextractedListings_Call {
	return &MockStore_ListUnextractedListings_Call{Call: _e.mock.On("ListUnextractedListings", ctx, limit)}
}

func (_c *MockStore_ListUnextractedListings_Call) Run(run func(ctx context.Context, limit int)) *MockStore_ListUnextractedListings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockStore_ListUnextractedListings_Call) Return(_a0 []domain.Listing, _a1 error) *MockStore_ListUnextractedListings_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_ListUnextractedListings_Call) RunAndReturn(run func(context.Context, int) ([]domain.Listing, error)) *MockStore_ListUnextractedListings_Call {
	_c.Call.Return(run)
	return _c
}

// ListUnscoredListings provides a mock function with given fields: ctx, limit
func (_m *MockStore) ListUnscoredListings(ctx context.Context, limit int) ([]domain.Listing, error) {
	ret := _m.Called(ctx, limit)

	if len(ret) == 0 {
		panic("no return value specified for ListUnscoredListings")
	}

	var r0 []domain.Listing
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]domain.Listing, error)); ok {
		return rf(ctx, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []domain.Listing); ok {
		r0 = rf(ctx, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Listing)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_ListUnscoredListings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUnscoredListings'
type MockStore_ListUnscoredListings_Call struct {
	*mock.Call
}

// ListUnscoredListings is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
func (_e *MockStore_Expecter) ListUnscoredListings(ctx interface{}, limit interface{}) *MockStore_ListUnscoredListings_Call {
	return &MockStore_ListUnscoredListings_Call{Call: _e.mock.On("ListUnscoredListings", ctx, limit)}
}

func (_c *MockStore_ListUnscoredListings_Call) Run(run func(ctx context.Context, limit int)) *MockStore_ListUnscoredListings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockStore_ListUnscoredListings_Call) Return(_a0 []domain.Listing, _a1 error) *MockStore_ListUnscoredListings_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_ListUnscoredListings_Call) RunAndReturn(run func(context.Context, int) ([]domain.Listing, error)) *MockStore_ListUnscoredListings_Call {
	_c.Call.Return(run)
	return _c
}

// ListWatches provides a mock function with given fields: ctx, enabledOnly
func (_m *MockStore) ListWatches(ctx context.Context, enabledOnly bool) ([]domain.Watch, error) {
	ret := _m.Called(ctx, enabledOnly)

	if len(ret) == 0 {
		panic("no return value specified for ListWatches")
	}

	var r0 []domain.Watch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, bool) ([]domain.Watch, error)); ok {
		return rf(ctx, enabledOnly)
	}
	if rf, ok := ret.Get(0).(func(context.Context, bool) []domain.Watch); ok {
		r0 = rf(ctx, enabledOnly)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Watch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, bool) error); ok {
		r1 = rf(ctx, enabledOnly)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_ListWatches_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListWatches'
type MockStore_ListWatches_Call struct {
	*mock.Call
}

// ListWatches is a helper method to define mock.On call
//   - ctx context.Context
//   - enabledOnly bool
func (_e *MockStore_Expecter) ListWatches(ctx interface{}, enabledOnly interface{}) *MockStore_ListWatches_Call {
	return &MockStore_ListWatches_Call{Call: _e.mock.On("ListWatches", ctx, enabledOnly)}
}

func (_c *MockStore_ListWatches_Call) Run(run func(ctx context.Context, enabledOnly bool)) *MockStore_ListWatches_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bool))
	})
	return _c
}

func (_c *MockStore_ListWatches_Call) Return(_a0 []domain.Watch, _a1 error) *MockStore_ListWatches_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_ListWatches_Call) RunAndReturn(run func(context.Context, bool) ([]domain.Watch, error)) *MockStore_ListWatches_Call {
	_c.Call.Return(run)
	return _c
}

// MarkAlertNotified provides a mock function with given fields: ctx, id
func (_m *MockStore) MarkAlertNotified(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for MarkAlertNotified")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_MarkAlertNotified_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkAlertNotified'
type MockStore_MarkAlertNotified_Call struct {
	*mock.Call
}

// MarkAlertNotified is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockStore_Expecter) MarkAlertNotified(ctx interface{}, id interface{}) *MockStore_MarkAlertNotified_Call {
	return &MockStore_MarkAlertNotified_Call{Call: _e.mock.On("MarkAlertNotified", ctx, id)}
}

func (_c *MockStore_MarkAlertNotified_Call) Run(run func(ctx context.Context, id string)) *MockStore_MarkAlertNotified_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStore_MarkAlertNotified_Call) Return(_a0 error) *MockStore_MarkAlertNotified_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_MarkAlertNotified_Call) RunAndReturn(run func(context.Context, string) error) *MockStore_MarkAlertNotified_Call {
	_c.Call.Return(run)
	return _c
}

// MarkAlertsNotified provides a mock function with given fields: ctx, ids
func (_m *MockStore) MarkAlertsNotified(ctx context.Context, ids []string) error {
	ret := _m.Called(ctx, ids)

	if len(ret) == 0 {
		panic("no return value specified for MarkAlertsNotified")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) error); ok {
		r0 = rf(ctx, ids)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_MarkAlertsNotified_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkAlertsNotified'
type MockStore_MarkAlertsNotified_Call struct {
	*mock.Call
}

// MarkAlertsNotified is a helper method to define mock.On call
//   - ctx context.Context
//   - ids []string
func (_e *MockStore_Expecter) MarkAlertsNotified(ctx interface{}, ids interface{}) *MockStore_MarkAlertsNotified_Call {
	return &MockStore_MarkAlertsNotified_Call{Call: _e.mock.On("MarkAlertsNotified", ctx, ids)}
}

func (_c *MockStore_MarkAlertsNotified_Call) Run(run func(ctx context.Context, ids []string)) *MockStore_MarkAlertsNotified_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockStore_MarkAlertsNotified_Call) Return(_a0 error) *MockStore_MarkAlertsNotified_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_MarkAlertsNotified_Call) RunAndReturn(run func(context.Context, []string) error) *MockStore_MarkAlertsNotified_Call {
	_c.Call.Return(run)
	return _c
}

// Migrate provides a mock function with given fields: ctx
func (_m *MockStore) Migrate(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Migrate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_Migrate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Migrate'
type MockStore_Migrate_Call struct {
	*mock.Call
}

// Migrate is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) Migrate(ctx interface{}) *MockStore_Migrate_Call {
	return &MockStore_Migrate_Call{Call: _e.mock.On("Migrate", ctx)}
}

func (_c *MockStore_Migrate_Call) Run(run func(ctx context.Context)) *MockStore_Migrate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_Migrate_Call) Return(_a0 error) *MockStore_Migrate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_Migrate_Call) RunAndReturn(run func(context.Context) error) *MockStore_Migrate_Call {
	_c.Call.Return(run)
	return _c
}

// Ping provides a mock function with given fields: ctx
func (_m *MockStore) Ping(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_Ping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ping'
type MockStore_Ping_Call struct {
	*mock.Call
}

// Ping is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) Ping(ctx interface{}) *MockStore_Ping_Call {
	return &MockStore_Ping_Call{Call: _e.mock.On("Ping", ctx)}
}

func (_c *MockStore_Ping_Call) Run(run func(ctx context.Context)) *MockStore_Ping_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_Ping_Call) Return(_a0 error) *MockStore_Ping_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_Ping_Call) RunAndReturn(run func(context.Context) error) *MockStore_Ping_Call {
	_c.Call.Return(run)
	return _c
}

// RecomputeAllBaselines provides a mock function with given fields: ctx, windowDays
func (_m *MockStore) RecomputeAllBaselines(ctx context.Context, windowDays int) error {
	ret := _m.Called(ctx, windowDays)

	if len(ret) == 0 {
		panic("no return value specified for RecomputeAllBaselines")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, windowDays)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_RecomputeAllBaselines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecomputeAllBaselines'
type MockStore_RecomputeAllBaselines_Call struct {
	*mock.Call
}

// RecomputeAllBaselines is a helper method to define mock.On call
//   - ctx context.Context
//   - windowDays int
func (_e *MockStore_Expecter) RecomputeAllBaselines(ctx interface{}, windowDays interface{}) *MockStore_RecomputeAllBaselines_Call {
	return &MockStore_RecomputeAllBaselines_Call{Call: _e.mock.On("RecomputeAllBaselines", ctx, windowDays)}
}

func (_c *MockStore_RecomputeAllBaselines_Call) Run(run func(ctx context.Context, windowDays int)) *MockStore_RecomputeAllBaselines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockStore_RecomputeAllBaselines_Call) Return(_a0 error) *MockStore_RecomputeAllBaselines_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_RecomputeAllBaselines_Call) RunAndReturn(run func(context.Context, int) error) *MockStore_RecomputeAllBaselines_Call {
	_c.Call.Return(run)
	return _c
}

// RecomputeBaseline provides a mock function with given fields: ctx, productKey, windowDays
func (_m *MockStore) RecomputeBaseline(ctx context.Context, productKey string, windowDays int) error {
	ret := _m.Called(ctx, productKey, windowDays)

	if len(ret) == 0 {
		panic("no return value specified for RecomputeBaseline")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int) error); ok {
		r0 = rf(ctx, productKey, windowDays)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_RecomputeBaseline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecomputeBaseline'
type MockStore_RecomputeBaseline_Call struct {
	*mock.Call
}

// RecomputeBaseline is a helper method to define mock.On call
//   - ctx context.Context
//   - productKey string
//   - windowDays int
func (_e *MockStore_Expecter) RecomputeBaseline(ctx interface{}, productKey interface{}, windowDays interface{}) *MockStore_RecomputeBaseline_Call {
	return &MockStore_RecomputeBaseline_Call{Call: _e.mock.On("RecomputeBaseline", ctx, productKey, windowDays)}
}

func (_c *MockStore_RecomputeBaseline_Call) Run(run func(ctx context.Context, productKey string, windowDays int)) *MockStore_RecomputeBaseline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockStore_RecomputeBaseline_Call) Return(_a0 error) *MockStore_RecomputeBaseline_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_RecomputeBaseline_Call) RunAndReturn(run func(context.Context, string, int) error) *MockStore_RecomputeBaseline_Call {
	_c.Call.Return(run)
	return _c
}

// SetWatchEnabled provides a mock function with given fields: ctx, id, enabled
func (_m *MockStore) SetWatchEnabled(ctx context.Context, id string, enabled bool) error {
	ret := _m.Called(ctx, id, enabled)

	if len(ret) == 0 {
		panic("no return value specified for SetWatchEnabled")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = rf(ctx, id, enabled)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_SetWatchEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetWatchEnabled'
type MockStore_SetWatchEnabled_Call struct {
	*mock.Call
}

// SetWatchEnabled is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - enabled bool
func (_e *MockStore_Expecter) SetWatchEnabled(ctx interface{}, id interface{}, enabled interface{}) *MockStore_SetWatchEnabled_Call {
	return &MockStore_SetWatchEnabled_Call{Call: _e.mock.On("SetWatchEnabled", ctx, id, enabled)}
}

func (_c *MockStore_SetWatchEnabled_Call) Run(run func(ctx context.Context, id string, enabled bool)) *MockStore_SetWatchEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *MockStore_SetWatchEnabled_Call) Return(_a0 error) *MockStore_SetWatchEnabled_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_SetWatchEnabled_Call) RunAndReturn(run func(context.Context, string, bool) error) *MockStore_SetWatchEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateListingExtraction provides a mock function with given fields: ctx, id, componentType, attrs, confidence, productKey
func (_m *MockStore) UpdateListingExtraction(ctx context.Context, id string, componentType string, attrs map[string]interface{}, confidence float64, productKey string) error {
	ret := _m.Called(ctx, id, componentType, attrs, confidence, productKey)

	if len(ret) == 0 {
		panic("no return value specified for UpdateListingExtraction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]interface{}, float64, string) error); ok {
		r0 = rf(ctx, id, componentType, attrs, confidence, productKey)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_UpdateListingExtraction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateListingExtraction'
type MockStore_UpdateListingExtraction_Call struct {
	*mock.Call
}

// UpdateListingExtraction is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - componentType string
//   - attrs map[string]interface{}
//   - confidence float64
//   - productKey string
func (_e *MockStore_Expecter) UpdateListingExtraction(ctx interface{}, id interface{}, componentType interface{}, attrs interface{}, confidence interface{}, productKey interface{}) *MockStore_UpdateListingExtraction_Call {
	return &MockStore_UpdateListingExtraction_Call{Call: _e.mock.On("UpdateListingExtraction", ctx, id, componentType, attrs, confidence, productKey)}
}

func (_c *MockStore_UpdateListingExtraction_Call) Run(run func(ctx context.Context, id string, componentType string, attrs map[string]interface{}, confidence float64, productKey string)) *MockStore_UpdateListingExtraction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(map[string]interface{}), args[4].(float64), args[5].(string))
	})
	return _c
}

func (_c *MockStore_UpdateListingExtraction_Call) Return(_a0 error) *MockStore_UpdateListingExtraction_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_UpdateListingExtraction_Call) RunAndReturn(run func(context.Context, string, string, map[string]interface{}, float64, string) error) *MockStore_UpdateListingExtraction_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateScore provides a mock function with given fields: ctx, id, score, breakdown
func (_m *MockStore) UpdateScore(ctx context.Context, id string, score int, breakdown json.RawMessage) error {
	ret := _m.Called(ctx, id, score, breakdown)

	if len(ret) == 0 {
		panic("no return value specified for UpdateScore")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, json.RawMessage) error); ok {
		r0 = rf(ctx, id, score, breakdown)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_UpdateScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateScore'
type MockStore_UpdateScore_Call struct {
	*mock.Call
}

// UpdateScore is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - score int
//   - breakdown json.RawMessage
func (_e *MockStore_Expecter) UpdateScore(ctx interface{}, id interface{}, score interface{}, breakdown interface{}) *MockStore_UpdateScore_Call {
	return &MockStore_UpdateScore_Call{Call: _e.mock.On("UpdateScore", ctx, id, score, breakdown)}
}

func (_c *MockStore_UpdateScore_Call) Run(run func(ctx context.Context, id string, score int, breakdown json.RawMessage)) *MockStore_UpdateScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(json.RawMessage))
	})
	return _c
}

func (_c *MockStore_UpdateScore_Call) Return(_a0 error) *MockStore_UpdateScore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_UpdateScore_Call) RunAndReturn(run func(context.Context, string, int, json.RawMessage) error) *MockStore_UpdateScore_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateWatch provides a mock function with given fields: ctx, w
func (_m *MockStore) UpdateWatch(ctx context.Context, w *domain.Watch) error {
	ret := _m.Called(ctx, w)

	if len(ret) == 0 {
		panic("no return value specified for UpdateWatch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.Watch) error); ok {
		r0 = rf(ctx, w)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_UpdateWatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateWatch'
type MockStore_UpdateWatch_Call struct {
	*mock.Call
}

// UpdateWatch is a helper method to define mock.On call
//   - ctx context.Context
//   - w *domain.Watch
func (_e *MockStore_Expecter) UpdateWatch(ctx interface{}, w interface{}) *MockStore_UpdateWatch_Call {
	return &MockStore_UpdateWatch_Call{Call: _e.mock.On("UpdateWatch", ctx, w)}
}

func (_c *MockStore_UpdateWatch_Call) Run(run func(ctx context.Context, w *domain.Watch)) *MockStore_UpdateWatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.Watch))
	})
	return _c
}

func (_c *MockStore_UpdateWatch_Call) Return(_a0 error) *MockStore_UpdateWatch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_UpdateWatch_Call) RunAndReturn(run func(context.Context, *domain.Watch) error) *MockStore_UpdateWatch_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertListing provides a mock function with given fields: ctx, l
func (_m *MockStore) UpsertListing(ctx context.Context, l *domain.Listing) error {
	ret := _m.Called(ctx, l)

	if len(ret) == 0 {
		panic("no return value specified for UpsertListing")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.Listing) error); ok {
		r0 = rf(ctx, l)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_UpsertListing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertListing'
type MockStore_UpsertListing_Call struct {
	*mock.Call
}

// UpsertListing is a helper method to define mock.On call
//   - ctx context.Context
//   - l *domain.Listing
func (_e *MockStore_Expecter) UpsertListing(ctx interface{}, l interface{}) *MockStore_UpsertListing_Call {
	return &MockStore_UpsertListing_Call{Call: _e.mock.On("UpsertListing", ctx, l)}
}

func (_c *MockStore_UpsertListing_Call) Run(run func(ctx context.Context, l *domain.Listing)) *MockStore_UpsertListing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.Listing))
	})
	return _c
}

func (_c *MockStore_UpsertListing_Call) Return(_a0 error) *MockStore_UpsertListing_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_UpsertListing_Call) RunAndReturn(run func(context.Context, *domain.Listing) error) *MockStore_UpsertListing_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStore creates a new instance of MockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStore {
	mock := &MockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
